<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Workplace Price Scanner</title>
  <style>
    :root { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    body { margin: 0; background: #0b0d12; color: #e8eaf0; }
    header { padding: 16px 18px; border-bottom: 1px solid #22283a; background: #0f1320; }
    header h1 { margin: 0; font-size: 18px; }
    main { max-width: 1040px; margin: 0 auto; padding: 18px; display: grid; gap: 16px; }
    .grid { display: grid; gap: 16px; grid-template-columns: 1.2fr 0.8fr; }
    @media (max-width: 900px) { .grid { grid-template-columns: 1fr; } }

    .card { background: #11172a; border: 1px solid #1f2740; border-radius: 14px; padding: 14px; box-shadow: 0 10px 30px rgba(0,0,0,0.25); }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    button {
      background: #2b67f6; color: #fff; border: 0; padding: 10px 12px;
      border-radius: 10px; cursor: pointer; font-weight: 700;
    }
    button.secondary { background: #25304f; }
    button.danger { background: #7a2230; }
    button:disabled { opacity: 0.6; cursor: not-allowed; }
    input, select {
    input, select, textarea {
      background: #0b1020; border: 1px solid #243056; color: #e8eaf0;
      padding: 10px 12px; border-radius: 10px; width: 100%;
      box-sizing: border-box;
    }
    textarea { min-height: 110px; resize: vertical; }

    #videoWrap { position: relative; overflow: hidden; border-radius: 14px; border: 1px solid #223055; background: #070a12; }
    video { width: 100%; height: auto; display: block; }
@@ -82,7 +83,8 @@
      <div style="height: 12px;"></div>

      <div id="videoWrap">
        <video id="video" playsinline></video>
        <!-- iPhone: playsinline + muted helps keep video inline and allows playback after user gesture -->
        <video id="video" playsinline muted></video>
        <div id="overlay"><div class="box"></div></div>
      </div>

@@ -91,15 +93,14 @@
      <div class="row">
        <button id="startBtn">Start Camera</button>
        <button class="secondary" id="stopBtn" disabled>Stop</button>
        <button class="secondary" id="torchBtn" disabled>Toggle Torch</button>
      </div>

      <div class="divider"></div>

      <div class="row">
        <div style="flex: 1; min-width: 260px;">
          <label class="muted" for="manualInput">Manual barcode lookup</label>
          <input id="manualInput" placeholder="Type / paste a barcode..." />
          <input id="manualInput" placeholder="Type / paste a barcode..." inputmode="numeric" />
        </div>
        <div style="width: 180px;">
          <label class="muted" for="qtyInput">Qty</label>
@@ -111,8 +112,24 @@
      </div>

      <p class="muted" style="margin: 12px 0 0;">
        Tip: Use good lighting and keep the barcode inside the blue box.
        iPhone tip: good lighting + hold 6–10 inches away + avoid glare.
      </p>

      <div class="divider"></div>

      <h3 style="margin: 0 0 8px; font-size: 14px;">Database (no backend)</h3>
      <p class="muted" style="margin: 0 0 10px;">
        GitHub Pages is static, so this app can’t write to GitHub directly. When you scan an unknown barcode,
        it lets you add an item locally, then <b>download an updated <code>items.json</code></b> to commit back to the repo.
      </p>

      <div class="row">
        <button class="secondary" id="exportBtn">Download updated items.json</button>
        <button class="danger" id="clearLocalBtn">Clear local saved items</button>
      </div>
      <div class="muted small" style="margin-top:8px;">
        Local changes saved: <span id="localCount">0</span> item(s)
      </div>
    </section>

    <aside class="card">
@@ -132,28 +149,26 @@

      <div style="height: 14px;"></div>

      <h3 style="margin: 0 0 8px; font-size: 14px;">How it works</h3>
      <p class="muted" style="margin: 0;">
        This page scans barcodes and looks up the result in <code>items.json</code>.
        Update <code>items.json</code> anytime to change prices.
        Loads from <code>items.json</code> in the repo and overlays your local additions.
      </p>
    </aside>
  </div>
</main>

<!-- ✅ Reliable UMD ZXing build (exposes window.ZXing) -->
<!-- ✅ Reliable ZXing UMD build (window.ZXing) -->
<script src="https://unpkg.com/@zxing/library@0.21.3/umd/index.min.js"></script>

<script>
  // ---------- Config ----------
  // ------------------ Config ------------------
  const ITEMS_DB_URL = "./items.json";
  const SCAN_THROTTLE_MS = 1200;
  // ---------------------------
  const LOCAL_KEY = "wps_local_items_v2";
  // -------------------------------------------

  const videoEl = document.getElementById("video");
  const startBtn = document.getElementById("startBtn");
  const stopBtn = document.getElementById("stopBtn");
  const torchBtn = document.getElementById("torchBtn");
  const cameraSelect = document.getElementById("cameraSelect");
  const statusText = document.getElementById("statusText");
  const statusPill = document.getElementById("statusPill");
@@ -167,14 +182,20 @@
  const lastBarcode = document.getElementById("lastBarcode");
  const lastTime = document.getElementById("lastTime");

  let itemsDb = [];
  let itemsMap = new Map(); // barcode -> item
  const exportBtn = document.getElementById("exportBtn");
  const clearLocalBtn = document.getElementById("clearLocalBtn");
  const localCountEl = document.getElementById("localCount");

  let baseDb = [];
  let baseMap = new Map();   // items.json
  let localDb = [];          // locally added/edited
  let localMap = new Map();  // barcode -> item
  let mergedMap = new Map(); // base + local overlay

  let codeReader = null;
  let currentStream = null;
  let lastScanTs = 0;
  let lastValue = "";
  let torchOn = false;
  let activeDeviceId = null;

  function setStatus(kind, text) {
    statusText.textContent = text;
@@ -183,22 +204,52 @@
    dot.textContent = "●";
  }

  async function loadDb() {
  function safeParseJson(text) {
    try { return JSON.parse(text); } catch { return null; }
  }

  function loadLocalDb() {
    const raw = localStorage.getItem(LOCAL_KEY);
    const parsed = raw ? safeParseJson(raw) : null;
    localDb = Array.isArray(parsed) ? parsed : [];
    localMap = new Map();
    for (const item of localDb) {
      if (item && item.barcode) localMap.set(String(item.barcode), item);
    }
    localCountEl.textContent = String(localMap.size);
  }

  function saveLocalDb() {
    localStorage.setItem(LOCAL_KEY, JSON.stringify(localDb, null, 2));
    loadLocalDb();
    rebuildMergedMap();
  }

  function rebuildMergedMap() {
    mergedMap = new Map(baseMap);
    for (const [k, v] of localMap.entries()) mergedMap.set(k, v);
  }

  async function loadBaseDb() {
    setStatus("warn", "Loading DB…");
    try {
      const res = await fetch(ITEMS_DB_URL, { cache: "no-store" });
      if (!res.ok) throw new Error(`DB fetch failed: ${res.status}`);
      itemsDb = await res.json();
      const json = await res.json();
      baseDb = Array.isArray(json) ? json : [];

      itemsMap = new Map();
      for (const item of itemsDb) {
        if (item && item.barcode) itemsMap.set(String(item.barcode), item);
      baseMap = new Map();
      for (const item of baseDb) {
        if (item && item.barcode) baseMap.set(String(item.barcode), item);
      }
      setStatus("ok", `DB loaded (${itemsMap.size} items)`);

      rebuildMergedMap();
      setStatus("ok", `DB loaded (repo: ${baseMap.size}, local: ${localMap.size})`);
    } catch (e) {
      console.error(e);
      rebuildMergedMap();
      setStatus("bad", "DB load error");
      tag.innerHTML = `<div class="muted">Could not load <code>items.json</code>. Make sure it exists in your repo root.</div>`;
      tag.innerHTML = `<div class="muted">Could not load <code>items.json</code>. Make sure it exists next to <code>index.html</code>.</div>`;
    }
  }

@@ -208,46 +259,181 @@
    return v.toLocaleString(undefined, { style: "currency", currency: "USD" });
  }

  function renderTag(barcode, qty = 1) {
    const key = String(barcode || "").trim();
    const item = itemsMap.get(key);

    const now = new Date();
    lastBarcode.textContent = key || "—";
    lastTime.textContent = now.toLocaleString();
  // iPhone/ZXing often scans UPC-A as EAN-13 with a leading 0
  function normalizeBarcode(raw) {
    const text = String(raw || "").trim();
    if (/^\d{13}$/.test(text) && text.startsWith("0")) return text.slice(1);
    return text;
  }

    const q = Math.max(1, parseInt(qty, 10) || 1);
  function nowStamp() {
    return new Date().toLocaleString();
  }

    if (!item) {
      tag.innerHTML = `
        <div class="muted">No match found for barcode:</div>
        <div style="font-size:18px; font-weight:800;" class="mono">${key || "—"}</div>
        <div class="muted">Add it to <code>items.json</code>.</div>
      `;
      return;
    }
  function escapeHtml(str) {
    return String(str)
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function renderTagForFound(item, barcode, qty) {
    const q = Math.max(1, parseInt(qty, 10) || 1);
    const unitPrice = Number(item.price);
    const total = Number.isFinite(unitPrice) ? unitPrice * q : null;

    tag.innerHTML = `
      <div class="muted">${item.department ? item.department : "Item"}</div>
      <div style="font-size:22px; font-weight:900; line-height:1.15;">${item.name || "Unnamed item"}</div>
      <div style="font-size:22px; font-weight:900; line-height:1.15;">${escapeHtml(item.name || "Unnamed item")}</div>

      <div class="price">${money(item.price)}</div>

      <div class="kvs">
        <div class="kv"><span>Barcode</span><span class="mono">${key}</span></div>
        ${item.sku ? `<div class="kv"><span>SKU</span><span class="mono">${item.sku}</span></div>` : ""}
        ${item.location ? `<div class="kv"><span>Location</span><span>${item.location}</span></div>` : ""}
        <div class="kv"><span>Barcode</span><span class="mono">${escapeHtml(barcode)}</span></div>
        ${item.sku ? `<div class="kv"><span>SKU</span><span class="mono">${escapeHtml(item.sku)}</span></div>` : ""}
        ${item.location ? `<div class="kv"><span>Location</span><span>${escapeHtml(item.location)}</span></div>` : ""}
        <div class="kv"><span>Qty</span><span>${q}</span></div>
        ${total !== null ? `<div class="kv"><span>Total</span><span>${money(total)}</span></div>` : ""}
      </div>

      ${item.note ? `<div class="muted">Note: ${item.note}</div>` : ""}
      ${item.note ? `<div class="muted">Note: ${escapeHtml(item.note)}</div>` : ""}
      <div class="muted small">Source: ${localMap.has(String(barcode)) ? "Local (not yet committed)" : "Repo items.json"}</div>
    `;
  }

  function upsertLocalItem(item) {
    const bc = String(item.barcode);
    const idx = localDb.findIndex(x => x && String(x.barcode) === bc);
    if (idx >= 0) localDb[idx] = item;
    else localDb.push(item);
    saveLocalDb();
  }

  function renderAddForm(barcode) {
    const existingLocal = localMap.get(String(barcode)) || null;

    tag.innerHTML = `
      <div class="muted">Unknown barcode</div>
      <div style="font-size:18px; font-weight:900;" class="mono">${escapeHtml(barcode)}</div>

      <div class="divider"></div>

      <div class="muted">Add item details (saved locally in this browser):</div>

      <label class="muted">Name</label>
      <input id="f_name" placeholder="e.g., Paper Towels (2-pack)" value="${existingLocal?.name ? escapeHtml(existingLocal.name) : ""}"/>

      <label class="muted">Price (USD)</label>
      <input id="f_price" type="number" step="0.01" min="0" placeholder="e.g., 4.99" value="${Number.isFinite(Number(existingLocal?.price)) ? Number(existingLocal.price) : ""}"/>

      <div class="row">
        <div style="flex:1; min-width: 180px;">
          <label class="muted">SKU (optional)</label>
          <input id="f_sku" placeholder="e.g., A-1001" value="${existingLocal?.sku ? escapeHtml(existingLocal.sku) : ""}"/>
        </div>
        <div style="flex:1; min-width: 180px;">
          <label class="muted">Department (optional)</label>
          <input id="f_dept" placeholder="e.g., Supplies" value="${existingLocal?.department ? escapeHtml(existingLocal.department) : ""}"/>
        </div>
      </div>

      <label class="muted">Location (optional)</label>
      <input id="f_loc" placeholder="e.g., Aisle 3 / Bay 2" value="${existingLocal?.location ? escapeHtml(existingLocal.location) : ""}"/>

      <label class="muted">Note (optional)</label>
      <input id="f_note" placeholder="e.g., Medium size" value="${existingLocal?.note ? escapeHtml(existingLocal.note) : ""}"/>

      <div class="row" style="margin-top: 10px;">
        <button id="saveItemBtn">Save item</button>
      </div>

      <div class="muted small" style="margin-top:10px;">
        After adding items, click <b>Download updated items.json</b> and commit it to GitHub.
      </div>
    `;

    document.getElementById("saveItemBtn").onclick = () => {
      const name = document.getElementById("f_name").value.trim();
      const price = Number(document.getElementById("f_price").value);
      const sku = document.getElementById("f_sku").value.trim();
      const dept = document.getElementById("f_dept").value.trim();
      const loc = document.getElementById("f_loc").value.trim();
      const note = document.getElementById("f_note").value.trim();

      if (!name) { alert("Name is required."); return; }
      if (!Number.isFinite(price)) { alert("Price must be a number (e.g., 4.99)."); return; }

      const item = {
        barcode: String(barcode),
        name,
        price: Math.round(price * 100) / 100,
        ...(sku ? { sku } : {}),
        ...(dept ? { department: dept } : {}),
        ...(loc ? { location: loc } : {}),
        ...(note ? { note } : {}),
        updated_at: new Date().toISOString()
      };

      upsertLocalItem(item);
      renderTag(item.barcode, qtyInput.value);
    };
  }

  function renderTag(barcode, qty = 1) {
    const raw = String(barcode || "").trim();
    const key = normalizeBarcode(raw);

    lastBarcode.textContent = key || "—";
    lastTime.textContent = nowStamp();

    if (!key) {
      tag.innerHTML = `<div class="muted">No barcode provided.</div>`;
      return;
    }

    const item = mergedMap.get(String(key));
    if (item) renderTagForFound(item, key, qty);
    else renderAddForm(key);
  }

  function downloadText(filename, text) {
    const blob = new Blob([text], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
  }

  function exportMergedDb() {
    const out = Array.from(mergedMap.values());
    out.sort((a, b) => String(a.barcode).localeCompare(String(b.barcode)));
    downloadText("items.json", JSON.stringify(out, null, 2));
  }

  function buildReader() {
    // Strong hints for iPhone reliability
    const hints = new Map();
    hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [
      ZXing.BarcodeFormat.UPC_A,
      ZXing.BarcodeFormat.UPC_E,
      ZXing.BarcodeFormat.EAN_13,
      ZXing.BarcodeFormat.EAN_8,
      ZXing.BarcodeFormat.CODE_128,
      ZXing.BarcodeFormat.CODE_39,
      ZXing.BarcodeFormat.ITF
    ]);
    hints.set(ZXing.DecodeHintType.TRY_HARDER, true);

    // 200ms between scans helps iPhone pick up frames without lag
    return new ZXing.BrowserMultiFormatReader(hints, 200);
  }

  async function listCameras() {
    const devices = await navigator.mediaDevices.enumerateDevices();
    const videoInputs = devices.filter(d => d.kind === "videoinput");
@@ -260,118 +446,87 @@
      cameraSelect.appendChild(opt);
    });

    if (activeDeviceId) cameraSelect.value = activeDeviceId;
    return videoInputs;
  }

  async function startCamera(deviceId) {
    // ✅ Updated: check window.ZXing
    if (!window.ZXing) {
      setStatus("bad", "Scanner library missing");
      return;
    }
  async function startScanner() {
    if (!window.ZXing) { setStatus("bad", "Scanner library missing"); return; }
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) { setStatus("bad", "Camera not supported"); return; }

    setStatus("warn", "Starting camera…");

    if (currentStream) stopCamera();
    // (Re)create reader each time (helps iOS)
    if (codeReader) { try { codeReader.reset(); } catch {} }
    codeReader = buildReader();

    const constraints = {
      video: deviceId ? { deviceId: { exact: deviceId } } : { facingMode: "environment" },
      audio: false
    };
    // Warm-up: request environment cam first (improves autofocus + permissions)
    const warm = await navigator.mediaDevices.getUserMedia({ video: { facingMode: "environment" }, audio: false });
    warm.getTracks().forEach(t => t.stop());

    currentStream = await navigator.mediaDevices.getUserMedia(constraints);
    videoEl.srcObject = currentStream;
    await videoEl.play();
    // After permission, device labels appear
    await listCameras().catch(() => {});

    // Torch support check
    torchBtn.disabled = true;
    torchOn = false;
    try {
      const track = currentStream.getVideoTracks()[0];
      const caps = track.getCapabilities ? track.getCapabilities() : {};
      if (caps.torch) torchBtn.disabled = false;
    } catch {}

    // ✅ Updated: ZXing.BrowserMultiFormatReader
    codeReader = codeReader || new ZXing.BrowserMultiFormatReader();
    activeDeviceId = cameraSelect.value || null;

    startBtn.disabled = true;
    stopBtn.disabled = false;

    setStatus("ok", "Scanning…");

    // Decode loop
    const selectedDeviceId = deviceId || undefined;
    codeReader.decodeFromVideoDevice(selectedDeviceId, videoEl, (result, err) => {
      if (result) {
        const text = result.getText();
        const now = Date.now();
    // iOS-stable decode loop
    codeReader.decodeFromVideoDevice(activeDeviceId, videoEl, (result, err) => {
      if (!result) return;

        // Throttle duplicates
        if (text === lastValue && (now - lastScanTs) < SCAN_THROTTLE_MS) return;
      const raw = result.getText();
      const text = normalizeBarcode(raw);
      const now = Date.now();

        lastValue = text;
        lastScanTs = now;
      if (text === lastValue && (now - lastScanTs) < SCAN_THROTTLE_MS) return;

        renderTag(text, qtyInput.value);
      }
      lastValue = text;
      lastScanTs = now;

      renderTag(text, qtyInput.value);
    });
  }

  function stopCamera() {
    try {
      if (codeReader) codeReader.reset();
    } catch {}
    // Refresh list again shortly after start (more reliable on iOS)
    setTimeout(() => { listCameras().catch(() => {}); }, 700);
  }

    if (currentStream) {
      currentStream.getTracks().forEach(t => t.stop());
      currentStream = null;
    }
  function stopScanner() {
    try { if (codeReader) codeReader.reset(); } catch {}
    videoEl.srcObject = null;

    startBtn.disabled = false;
    stopBtn.disabled = true;
    torchBtn.disabled = true;
    torchOn = false;

    setStatus("warn", "Stopped");
  }

  async function toggleTorch() {
    if (!currentStream) return;
    const track = currentStream.getVideoTracks()[0];
    if (!track || !track.applyConstraints) return;

    try {
      torchOn = !torchOn;
      await track.applyConstraints({ advanced: [{ torch: torchOn }] });
    } catch (e) {
      console.warn("Torch not supported:", e);
    }
  }

  // ---------- Events ----------
  // Events
  startBtn.addEventListener("click", async () => {
    try {
      await loadDb();
      await listCameras();
      await startCamera(cameraSelect.value);
      await loadBaseDb();
      await startScanner();
    } catch (e) {
      console.error(e);
      setStatus("bad", "Camera error");
      tag.innerHTML = `<div class="muted">Could not start camera. Make sure you allowed camera access and are using HTTPS (GitHub Pages).</div>`;
      tag.innerHTML = `<div class="muted">Could not start camera. Make sure you opened the GitHub Pages URL (HTTPS) and allowed camera access.</div>`;
      startBtn.disabled = false;
      stopBtn.disabled = true;
    }
  });

  stopBtn.addEventListener("click", stopCamera);
  torchBtn.addEventListener("click", toggleTorch);
  stopBtn.addEventListener("click", stopScanner);

  cameraSelect.addEventListener("change", async () => {
    if (!currentStream) return;
    await startCamera(cameraSelect.value);
    if (stopBtn.disabled) return;
    try {
      stopScanner();
      await startScanner();
    } catch {}
  });

  reloadDbBtn.addEventListener("click", loadDb);
  reloadDbBtn.addEventListener("click", loadBaseDb);

  manualBtn.addEventListener("click", () => {
    const code = manualInput.value.trim();
@@ -382,8 +537,20 @@
    if (e.key === "Enter") manualBtn.click();
  });

  // Initial DB load (no camera needed)
  loadDb();
  exportBtn.addEventListener("click", exportMergedDb);

  clearLocalBtn.addEventListener("click", () => {
    const ok = confirm("Clear all locally saved items? This does NOT change items.json in GitHub.");
    if (!ok) return;
    localStorage.removeItem(LOCAL_KEY);
    loadLocalDb();
    rebuildMergedMap();
    setStatus("ok", `Local cleared (repo: ${baseMap.size}, local: 0)`);
  });

  // Init
  loadLocalDb();
  loadBaseDb();
</script>
</body>
</html>
